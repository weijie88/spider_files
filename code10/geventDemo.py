'''
协程原理：利用一个线程，分解一个线程成为多个“微线程”==>程序级别

如果写爬虫，就访问别的网站，拿别人源码。http请求叫IO请求，用多线程。
假设要访问3个url，创建3个线程，都在等待着，第一个有数据返回就继续执行，以此类推。
在等待过程中，就什么事也没干。

协程的方式。
计算机帮你创建进程、线程。线程是人为创建出来的。用一个线程，一会儿执行这个操作，
一会儿执行那个操作。
协程是只用一个线程。程序员利用io多路复用的方式，让协程：
先访问一个url，不等待返回，就再访问第二个url，访问第三个url，然后也在等待。
greenlet本质是实现协程的。
注意：协程本身不高效，协程的本质只是程序员调用的，那为啥gevent这么高效率呢，
是因为用了协程（greenlet）+IO多路复用的方式。
是IO多路复用的用法才能高效。所以用的时候就用gevent就好了。


用多线程：假设每爬一个网址需要2秒，3个url，就是3个请求，等待2秒，就可以继续往下走。
如果用gevent，用单线程，单线程应该从上到下执行，用for循环读取3个url，
往地址发送url请求，就是IO请求，线程是不等待的。
for循环再拿第二个url，再发第三个url。在这过程中，谁先回来，就处理谁。

资源占用上，多线程占用了3个线程，2秒钟，多线程啥也没干，在等待。gevent在2秒钟，
只要发送请求了，接着就想干什么干什么。
'''
import greenlet

def fun1():
    print("12")
    gr2.switch()
    print("56")
    gr2.switch()
def fun2():
    print("34")
    gr1.switch()
    print("78")
    gr1.switch()

gr1 = greenlet.greenlet(fun1)
gr2 = greenlet.greenlet(fun2)
gr2.switch()